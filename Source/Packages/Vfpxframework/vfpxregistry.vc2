*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="vfpxregistry.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS vfpxregistry AS custom 		&& A class that works with the Windows Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "vfpxregistry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Close the current registry key
		*m: deletekey		&& Delete the specified key
		*m: deletekeyvalue		&& Deletes a value under a key
		*m: enumeratekeys		&& Enumerate key names from the specfied key
		*m: enumeratekeyvalues		&& Enumerate values under the specified key
		*m: getkey		&& Gets the value for the specified key
		*m: iskey		&& Returns .T. if the specified key exists
		*m: iskeyvalue		&& Returns .T. if the specified key value exists
		*m: moveregistrykeys		&& Moves all keys and values from one location to another
		*m: openkey		&& Opens the specified key
		*m: setkey		&& Sets the specified key to the specified value
		*p: ncurrentkey		&& The current open key
		*p: nmainkey		&& The main key for the Registry
		*p: nresult		&& The result code of the most recent method call
	*</DefinedPropArrayMethod>

	PROTECTED ncurrentkey
	*<PropValue>
		Name = "vfpxregistry"
		ncurrentkey = 0
		nmainkey = 0
		nresult = 0
		Width = 17
	*</PropValue>
	
	PROTECTED PROCEDURE closekey		&& Close the current registry key
		* Close the current key and blank the current key value.
		
		with This
			RegCloseKey(.nCurrentKey)
			.nCurrentKey = 0 
		endwith
		
	ENDPROC

	PROCEDURE deletekey		&& Delete the specified key
		* Delete the specified key and all subkeys and values under it.
		
		lparameters tcSubKey, ;
			tnMainKey
		local laKeys[1], ;
			lnKeys, ;
			llReturn, ;
			lnI, ;
			lcKey, ;
			lnMainKey, ;
			lcSubKey
		with This
		
		* Call ourselves recursively to delete all subkeys first.
		
			lnKeys   = .EnumerateKeys(tcSubKey, @laKeys, tnMainKey)
			llReturn = .T.
			for lnI = 1 to lnKeys
				lcKey    = addbs(tcSubKey) + laKeys[lnI]
				llReturn = .DeleteKey(lcKey, tnMainKey)
				if not llReturn
					exit
				endif not llReturn
			next lnI
			if llReturn
		
		* If the main key wasn't passed, use the default value.
		
				lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, ;
					.nMainKey, tnMainKey)
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
				lcSubKey = iif(right(tcSubKey, 1) = '\', ;
					left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteKey(lnMainKey, lcSubKey)
				llReturn = .nResult = cnSUCCESS
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes a value under a key
		* Delete the specified value in the specified key.
		
		lparameters tcSubKey, ;
			tcValue, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteValue(.nCurrentKey, tcValue)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the value.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE enumeratekeys		&& Enumerate key names from the specfied key
		lparameters tcSubKey, ;
			taKeyNames, ;
			tnMainKey
		local lnMainKey, ;
			lnNames, ;
			lcKey, ;
			lnSize, ;
			lcBuffer1, ;
			lnSize1, ;
			lcBuffer2
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnNames  = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnSize    = cnBUFFER_SIZE
					lcBuffer1 = space(cnBUFFER_SIZE)
					lnSize1   = cnBUFFER_SIZE
					lcBuffer2 = space(cnBUFFER_SIZE)
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, @lnSize, ;
						cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey   = alltrim(lcKey)
							lcKey   = left(lcKey, len(lcKey) - 1)
							lnNames = lnNames + 1
							dimension taKeyNames[lnNames]
							taKeyNames[lnNames] = lcKey
		
		* If we had an error and it's not EOF, return an error code.
		
						case .nResult <> cnERROR_EOF
							lnNames = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnNames = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnNames
		
	ENDPROC

	PROCEDURE enumeratekeyvalues		&& Enumerate values under the specified key
		lparameters tcSubKey, ;
			taKeyValues, ;
			tnMainKey
		local lnMainKey, ;
			lnValues, ;
			lcKey, ;
			lnKeySize, ;
			lcValue, ;
			lnValSize, ;
			lnType, ;
			lcBuffer, ;
			lnSize
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnValues = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnKeySize = cnBUFFER_SIZE
					lcValue   = space(cnBUFFER_SIZE)
					lnValSize = cnBUFFER_SIZE
					lnType    = 0
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
						@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey    = left(lcKey, lnKeySize)
							lnValues = lnValues + 1
							dimension taKeyValues[lnValues, 2]
							taKeyValues[lnValues, 1] = lcKey
							do case
								case lnType = cnREG_SZ
									taKeyValues[lnValues, 2] = left(lcValue, ;
										lnValSize - 1)
								case lnType = cnREG_DWORD
									taKeyValues[lnValues, 2] = ctobin(left(lcValue, 4), ;
										'4RS')
								case lnType = cnREG_EXPAND_SZ
									lcValue  = left(lcValue, lnValSize - 1)
									lcBuffer = space(cnBUFFER_SIZE)
									lnSize   = cnBUFFER_SIZE
									lnSize   = ExpandEnvironmentStrings(@lcValue, ;
										@lcBuffer, lnSize)
									taKeyValues[lnValues, 2] = left(lcBuffer, ;
										lnSize - 1)
								case lnType = cnREG_BINARY
									taKeyValues[lnValues, 2] = left(lcValue, lnValSize)
								case lnType = cnREG_MULTI_SZ
									taKeyValues[lnValues, 2] = strtran(left(lcValue, ;
										lnValSize - 1), ccNULL, ccCR)
										&& use ALINES() on the return value to get the individual
										&& values
							endcase
		
		* If we had an error and it's not EOF, return 0 entries.
		
						case .nResult <> cnERROR_EOF
							lnValues = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnValues = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnValues
		
	ENDPROC

	PROCEDURE getkey		&& Gets the value for the specified key
		lparameters tcSubKey, ;
			tcValueName, ;
			tuDefault, ;
			tnMainKey, ;
			tl64Bit
		local lnMainKey, ;
			luValue, ;
			lcValueName, ;
			lcBuffer, ;
			lnSize, ;
			lnType, ;
			lnFlags
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the default to use wasn't passed, initialize it to an empty string.
		
			luValue = iif(vartype(tuDefault) = 'C', tuDefault, '')
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Create a buffer to hold the key value.
		
			lcBuffer = space(cnBUFFER_SIZE)
			lnSize   = cnBUFFER_SIZE
			lnType   = 0
		
		* If we're supposed to get a 64-bit value, do so.
		
			do case
				case tl64Bit
					lnFlags  = cnRRF_RT_ANY + cnRRF_SUBKEY_WOW6464KEY
					.nResult = RegGetValue(.nCurrentKey, tcSubKey, lcValueName, ;
						lnFlags, @lnType, @lcBuffer, @lnSize)
		
		* Get a 32-bit value.
		
				case .OpenKey(tcSubKey, lnMainKey)
					.nResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						@lnType, @lcBuffer, @lnSize)
					.CloseKey()
			endcase
		
		* Get the key value and convert it into the proper return value based on the
		* data type.
		
			do case
				case .nResult <> cnSUCCESS
				case lnType = cnREG_SZ
					luValue = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_EXPAND_SZ
					luValue  = left(lcBuffer, lnSize - 1)
					lcBuffer = space(cnBUFFER_SIZE)
					lnSize   = cnBUFFER_SIZE
					lnSize   = ExpandEnvironmentStrings(@luValue, @lcBuffer, ;
						lnSize)
					luValue  = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_DWORD
					luValue = ctobin(left(lcBuffer, 4), '4RS')
				case lnType = cnREG_BINARY
					luValue = left(lcBuffer, lnSize)
				case lnType = cnREG_MULTI_SZ
					luValue = strtran(left(lcBuffer, lnSize - 1), ccNULL, ccCR)
						&& use ALINES() on the return value to get the individual
						&& values
			endcase
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE Init
		lparameters tnMainKey
		
		* Declare the API functions we'll need.
		
		declare integer RegOpenKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegCreateKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegDeleteKey in Win32API ;
			integer nKey, string @cSubKey
		declare integer RegCloseKey in Win32API ;
			integer nKey
		declare integer RegSetValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer nType, string cBuffer, integer nBufferSize
		declare integer RegQueryValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer @nType, string @cBuffer, integer @nBufferSize
		declare integer RegDeleteValue in Win32API ;
			integer nKey, string cSubKey
		declare integer RegEnumKey in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize
		declare integer RegEnumKeyEx in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
			integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
		declare integer RegEnumValue IN Win32API ;
			integer nKey, integer nValue, string @cSubKey, ;
			integer @nKeySize, integer nReserved, integer @nType, ;
			string @cValue, integer @nValSize
		declare integer ExpandEnvironmentStrings IN Win32API ;
			string @lpSrc, string @lpDst, integer nSize
		declare integer RegGetValue IN Win32API ;
			integer hkey, string lpSubKey, string lpValue, integer dwFlags, ;
			integer @pdwType, string @pvData, integer @pcbData
		
		* Initialize the main key.
		
		This.nMainKey = iif(vartype(tnMainKey) = 'N', tnMainKey, cnHKEY_CURRENT_USER)
		
		* Carry on with the base behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE iskey		&& Returns .T. if the specified key exists
		lparameters tcSubKey, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we could, the key exists, so close it.
		
			llReturn = .OpenKey(tcSubKey, lnMainKey)
			if llReturn
				.CloseKey()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE iskeyvalue		&& Returns .T. if the specified key value exists
		lparameters tcSubKey, ;
			tcValueName, ;
			tnMainKey
		This.GetKey(tcSubKey, tcValueName, , tnMainKey)
		return This.nResult = cnSUCCESS
		
	ENDPROC

	PROCEDURE moveregistrykeys		&& Moves all keys and values from one location to another
		lparameters tcOldKey, ;
			tcNewKey, ;
			tlNoDelete
		local laKeys[1], ;
			lnKeys, ;
			lnI, ;
			lcKey, ;
			lcOldKey, ;
			lcNewKey, ;
			laValues[1], ;
			lnValues
		with This
		
		* Get all subkeys and call ourselves recursively to get all subkeys of those
		* and copy them to the new location (and possibly remove them from the old
		* location).
		
			lnKeys = .EnumerateKeys(tcOldKey, @laKeys)
			for lnI = 1 to lnKeys
				lcKey    = laKeys[lnI]
				lcOldKey = addbs(tcOldKey) + lcKey
				lcNewKey = addbs(tcNewKey) + lcKey
				.MoveRegistryKeys(lcOldKey, lcNewKey, tlNoDelete)
			next lnI
		
		* Get all values copy them to the new location (and possibly remove them from
		* the old location).
		
			lnValues = .EnumerateKeyValues(tcOldKey, @laValues)
			for lnI = 1 to lnValues
				.SetKey(tcNewKey, laValues[lnI, 1], laValues[lnI, 2])
			next lnI
			if not tlNoDelete
				.DeleteKey(tcOldKey)
			endif not tlNoDelete
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE openkey		&& Opens the specified key
		lparameters tcSubKey, ;
			tnMainKey, ;
			tlCreate
		local lnHandle, ;
			lcSubKey, ;
			llReturn
		
		* Try to create or open the registry key. If it succeeded, store the key handle
		* in the nCurrentKey property; if not, zero nCurrentKey.
		
		with This
			lnHandle = 0
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
			lcSubKey = iif(right(tcSubKey, 1) = '\', ;
				left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
			if tlCreate
				.nResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
			else
				.nResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
			endif tlCreate
			llReturn     = .nResult = cnSUCCESS
			.nCurrentKey = iif(llReturn, lnHandle, 0)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setkey		&& Sets the specified key to the specified value
		lparameters tcSubKey, ;
			tcValueName, ;
			tuValue, ;
			tnMainKey, ;
			tnType
		local lnMainKey, ;
			lcDataType, ;
			lcValue, ;
			lnSize, ;
			lcValueName, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the type wasn't specified, initialize it to cnREG_SZ.
		
			lnType = iif(vartype(tnType) = 'N', tnType, cnREG_SZ)
		
		* Convert the value to a string if necessary. Terminate the string with a null
		* and calculate the size.
		
			lcDataType = vartype(tuValue)
			do case
				case lnType = cnREG_MULTI_SZ
					lcValue = strtran(tuValue, ccCR, ccNULL)
				case lcDataType = 'C'
					lcValue = tuValue
				case lcDataType $ 'NIFYB' and lnType = cnREG_DWORD
					lcValue = bintoc(tuValue, '4RS')
				case lcDataType $ 'NIFYB'
					lcValue = transform(tuValue)
				case lcDataType = 'D'
					lcValue = dtoc(tuValue)
				case lcDataType = 'T'
					lcValue = ttoc(tuValue)
				case lcDataType = 'L'
					lcValue = iif(tuValue, 'Y', 'N')
			endcase
			if inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
				lcValue = lcValue + ccNULL
			endif inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
			lnSize = len(lcValue)
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Try to open or create the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey, .T.)
		
		* Set the key value.
		
				.nResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
					lnType, lcValue, lnSize)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the success flag.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey, .T.)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
